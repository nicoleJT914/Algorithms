二分查找 ==> 递归版本
```
 public int rank(Key key, int lo, int hi) {
   if(hi<lo) return lo;
   int mid = lo+(hi-lo)/2;
   int cmp = key.compareTo(keys[mid]);
   if (cmp<0) return rank(key, lo, mid-1)
   if (cmp>0) return rank(key, mid+1, hi)
   else return mid;
}
```
N个键的有序数组中进行二分查找最多需要(lgN+1)此比较（无论是否成功）
Page 241
